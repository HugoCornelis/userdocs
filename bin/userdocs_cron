#!/usr/bin/perl
#!/usr/bin/perl -w -d:ptkdb

use strict;
use Getopt::Long;
use YAML;


my $output_filename = "userdocs_cron.out";


#
# options
#
my $option_output_directory = "/tmp";
my $option_config = "";
my $option_html_output_directory = "~/public_html";

my $configuration
    = {
      };


sub main
{

  {
    my $result
      = GetOptions
	(
	 "outputdir=s" => \$option_output_directory,
	 "config=s" => \$option_config,
	);

  }


  if ($option_config)
  {
    parse_config_file($option_config);
  }


  my $output_path = $option_output_directory . "/" . $output_filename;

  $ENV{PATH} .= ':/bin:/usr/bin:/usr/local/bin';


  try_to("neurospaces_pull --regex userdocs",1); 

  try_to("neurospaces_update --regex userdocs",1); 

  try_to("neurospaces_configure --regex userdocs",1);

  try_to("neurospaces_install --regex userdocs",1);

  try_to("neurospaces_clean --regex userdocs",1);

  try_to("make website-prepare -C ~/neurospaces_project/userdocs/source/snapshots/0/ > $output_path",1);

  # now do a link check.
  try_to("make webcheck -C ~/neurospaces_project/userdocs/source/snapshots/0/ > $output_path",1);

  my $text = produce_email_text();

  try_to_mail("Userdocs has been built.",
	      "Userdocs has finished building.\n\n" . $text);

  copy_html_data();


}



#
# Forms the status message to be sent
# in the cronjob email.
#
sub produce_email_text
{

  my $status_message = "";
  my $outputfile = $option_output_directory . "/" . $output_filename;
  my $die_messages = `grep die $outputfile`;

  $status_message
      .= (
	  "$0:\nCheck for your output on the host machine here "
	  . $option_output_directory
	  . "/"
	  . $output_filename . "\n"
	 );

  if (defined $configuration->{URL})
  {
      $status_message .= "Check the test output over the web via this link " . $configuration->{URL} . "\n";
  }


  #
  # Now find all of the log files and check for error messages
  #
  my $errors = "";

  my $logfiletext = `find . | grep output | grep \.log`;

  my @logfiles = split(/\n/,$logfiletext);

  my $logfile;

  foreach $logfile(@logfiles)
  {
    my $latexerrors = `cat $logfile | grep ^!`;

    if($latexerrors eq "")
    {

      next;

    }
    else
    {
      #my $filename = $logfile;
      #$filename =~ m(.*output/(.*)\.log$);
      my @tmp = split(/\//,$logfile);
      my $tmp = $tmp[-1];
      @tmp = split(/\./,$tmp);
      my $filename = $tmp[0];

      $status_message .= "\n\n"; 
      $status_message .= "Error in document: ";
      $status_message .= $filename;
      $status_message .= " : \n\t";
      $status_message .= $latexerrors;
    }

  }

  return $status_message;

}


#
# This will actually send mail.
#
# args ($subject,$message)
#
sub try_to_mail
{
    my $subject = shift;
    my $message = shift;

    if (!$configuration->{MAILTO})
    {
      print "No addressee indicated in configuration\n";
      return;
    }

    my $sendto = $configuration->{MAILTO};
    my $replyto = $configuration->{MAILFROM};

    #todo figure out why I can't put the output of
    # `which sendmail` into a variable and put it in 
    # place of the /usr/sbin/sendmail. A user may have 
    # a different sendmail path.

    #t Mando: perhaps /sbin/ is not in the PATH, such that which does
    #t not find sendmail when things run over cron?

    open(MAIL, "|/usr/sbin/sendmail -oi -t");
    print MAIL "From: $replyto\n";
    print MAIL "To: $sendto\n";
    print MAIL "Subject: $subject\n\n";
    print MAIL "$message\n";
    close(MAIL);

}


#
# ("command",vebosity level)
#
sub try_to
{
    my $command = shift;

    my $no_verbose = shift;

    my $allow_fail = shift;

    if (!$no_verbose)
    {
	print "---\n";
	print "$0: trying to $command\n";
    }

    my $output_path = $option_output_directory . "/" . $output_filename;

    #! $command executed in a subshell such that redirection applies
    #! to all commands.

    system "( $command ) >>$output_path 2>&1";

    if ($?)
    {
	if ($allow_fail)
	{
	    system "echo >>$output_path 2>&1 failed with $?: $command\n";
	}
	else
	{
	    report_error($command, $?);
	}
    }
}





sub report_error
{
    my $command = shift;

    my $error_code = shift;

    try_to_mail("userdocs_cron error", "$0: $command returned $error_code");

    die "$0: $command returned $error_code";
}


#
# copies the resulting html data to a directory specified in
# the config file and then sets up a sym link for it.
#
# It copies over the userdocs html data into a directory, then symlinks
# to that directory.
#
# operations performed:
#   cp userdocs_data html_dir/userdocs_data
#   ln -s html_dir/userdocs_data html_dir/userdocs
#
sub copy_html_data
{

  my $html_symlink = $option_html_output_directory . "/" . "userdocs";
  my $html_data_directory = $option_html_output_directory . "/" . "userdocs_data";
  my $html_build_directory = 
    "~/neurospaces_project/userdocs/source/snapshots/0/html/htdocs/neurospaces_project/userdocs/";

  try_to("rm -rf $html_data_directory");
  try_to("cp -rf $html_build_directory $html_data_directory",1);
  try_to("rm -f $html_symlink",1);
  try_to("ln -s $html_data_directory $html_symlink",1);

}


#
# ($config_file) a file with a configuration in it.
#
sub parse_config_file
{
  my $config_file = shift;

  if (! -e $config_file)
  {
      print "\n$config_file is an invalid filename\n";

      return;
  }

  print "\nParsing configuration in $config_file\n\n";

  $configuration = YAML::LoadFile($config_file);


  if(!defined $configuration)
  {

    print "This YAML file is invalid\n";
    return;

  }

  if(defined $configuration->{MAILTO})
  {
    chomp($configuration->{MAILTO});
    print "\tSend to email: $configuration->{MAILTO}\n";
  }

  if(defined $configuration->{MAILFROM})
  {
    chomp($configuration->{MAILFROM});
    print "\tSend from email: $configuration->{MAILFROM}\n";
  }


  if(defined $configuration->{HTMLDIR})
  {
    $option_html_output_directory = $configuration->{HTMLDIR};
    chomp($configuration->{HTMLDIR});
    print "\tThe directory for html output is: $configuration->{HTMLDIR}\n";
  }

  if(defined $configuration->{OUTPUTDIR})
  {
      #! note that this overrides an option from set by the command line

      $option_output_directory = $configuration->{OUTPUTDIR};
      chomp($option_output_directory);
      print "\tOutput directory is $option_output_directory\n";
  }


  if(defined $configuration->{URL})
  {
      chomp($configuration->{URL});
      print "\tThe link for accessing the userdocs is $configuration->{URL}\n";
  }


  print "Done Parsing $config_file:\n";

}



#
# run the main program.
#
main();

