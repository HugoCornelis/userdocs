#!/usr/bin/perl -w 
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


use Getopt::Long;

use YAML;


my $option_verbose;
my $option_tags = [];


sub build_document
{
    my $document = shift;

#     $document = m((.*)/(.*));

    my $directory = $document;

#     my $filename = $2;

    if ($option_verbose)
    {
	print "$0: entering $directory\n";
    }

    chdir $directory;

    # if we find a makefile

    if (-f 'Makefile')
    {
	# that is what we use

	system "make build_document";
    }
    else
    {
	# find relevant source files

	my $filenames
	    = [
	       map
	       {
		   chomp; $_
	       }
	       `ls *.tex`,
	      ];

	# loop over source files

	foreach my $filename (@$filenames)
	{
	    # for latex sources

	    if ($filename =~ /\.tex$/)
	    {
		# prepare output: general latex processing

		$filename =~ m((.*)\.tex$);

		my $filename_base = $1;

		system "latex '$filename'";

		system "makeindex -c '$filename_base'";

		system "bibtex '$filename_base'";

		system "latex '$filename'";
		system "latex '$filename'";

		# generate ps output

		{
		    mkdir "output_ps";

		    if ($option_verbose)
		    {
			print "$0: entering output_ps\n";
		    }

		    chdir "output_ps";

		    system "dvips '../$filename_base.dvi' -o '$filename_base.ps'";

		    if ($option_verbose)
		    {
			print "$0: leaving output_ps\n";
		    }

		    chdir "..";
		}

		# generate pdf output

		{
		    mkdir "output_pdf";

		    if ($option_verbose)
		    {
			print "$0: entering output_pdf\n";
		    }

		    chdir "output_pdf";

		    system "ps2pdf '../output_ps/$filename_base.ps' '$filename_base.pdf'";

		    if ($option_verbose)
		    {
			print "$0: leaving output_pdf\n";
		    }

		    chdir "..";
		}

		# generate html output

		{
		    mkdir 'output_html';
		    mkdir 'output_html/figures';

		    if ($option_verbose)
		    {
			print "$0: entering output_html\n";
		    }

		    chdir "output_html";

		    # read latex source

		    use IO::File;

		    my $source_file = IO::File->new("<../$filename");

		    my $source_text = join "", <$source_file>;

		    $source_file->close();

		    # convert pdf links to html links

		    $source_text =~ s(\\href\{\.\./([^}]*)\.pdf)(\\href\{../$1.html)g;

		    $source_text =~ s(\\href\{\.\./([^}]*)\.tex)(\\href\{../$1.html)g;

		    # convert eps links to png links

		    $source_text =~ s(\\includegraphics\{figures/([^}]*)\.eps)(\\href\{figures/$1.png)g;

		    # write converted source

		    $source_file = IO::File->new(">$filename");

		    print $source_file $source_text;

		    $source_file->close();

		    # copy figures

		    system "cp -rp ../figures/* figures/";

		    # generate html output

		    system "htlatex '$filename'";


		    if ($option_verbose)
		    {
			print "$0: leaving output_html\n";
		    }

		    chdir "..";
		}
	    }

	    # else unknown source file type

	    else
	    {
		print "$0: unknown file type for $filename";
	    }
	}
    }

    if ($option_verbose)
    {
	print "$0: leaving $directory\n";
    }

    chdir '..';
}




sub main
{
    read_cmd_line();

    # get all documents from the command line

    my $documents
	= {
	   map
	   {
	       $_ => 1,
	   }
	   @ARGV,
	  };

    # get all documents selected by tags

    foreach my $tag (@$option_tags)
    {
	my $documents_yaml = `userdocs-tag-filter 2>&1 "$tag"`;

	# get only documents with a publish tag
	my $published_docs_yaml = get_published($documents_yaml);

	my $yamldata = Load($published_docs_yaml);

	if(!defined $yamldata)
	{
	  next;
	}
	
	$documents
	    = {
	       %$documents,
	       map
	       {
		   $_ => 1,
	       }
	       @{ $yamldata  },
	      };
    }

    # make sure document names are 'compliant'

    map
    {
	s(/$)();
    }
	keys %$documents;

    # prepare directory structure

    `mkdir -p html/htdocs/neurospaces_project/userdocs/`;

    if (!scalar keys %$documents)
    {
	print "$0: no documents to build\n";
    }

    foreach my $document (keys %$documents)
    {
	build_document($document);
    }

    foreach my $document (keys %$documents)
    {
	prepare_publish_document($document);
    }
}



sub get_published
{
  my $documents = shift;

  my @docs = split(/\n/,$documents);

  shift @docs;

  my @published_documents;

  push(@published_documents,"---");

  my $desciptorfile;

  foreach (@docs)
  {


    $desciptorfile = substr($_,2) . "/descriptor.yml";

    my $yaml_name = $_;



    if(-e $desciptorfile)
    {


      my $descriptor = YAML::LoadFile($desciptorfile);

      # convert the tags to a hash with true values
      my $tags = $descriptor->{tags};

      my $ispublished = 0;



      foreach (@$tags)
      {
	if (/publish/i)
	{
	  $ispublished = 1;
	}
      }


	
      if($ispublished)
      {
	push(@published_documents,$yaml_name);
      }

    }
    else
    {
      next;
    }

  }

  return join("\n", @published_documents) . "\n";

}


sub prepare_publish_document
{
    my $document = shift;

#     $document = m((.*)/(.*));

    my $directory = $document;

#     my $filename = $2;

    if ($option_verbose)
    {
	print "$0: entering $directory\n";
    }

    chdir $directory;

    # if we find a makefile

    if (-f 'Makefile')
    {
	# that is what we use

	system "make prepare_publish_document";
    }

    # no makefile

    else
    {
	# find relevant output containing generated files

	my $outputs
	    = [
	       'output_html',
	      ];

	# loop over source files

	foreach my $output (@$outputs)
	{
	    if ($option_verbose)
	    {
		print "$0: copying files for $directory to html/htdocs/neurospaces_project/userdocs/$directory\n";
	    }

	    # put it in the place for publication.

	    mkdir "../html/htdocs/neurospaces_project/userdocs/$directory";

	    #! note: -pr for BSD (MAC) compatibility.

	    system "cp -pr $output/* '../html/htdocs/neurospaces_project/userdocs/$directory'";

	    if ($?)
	    {
		print "$0: cp '$output' failed for $directory (error code $?)\n";
	    }
	}
    }

    if ($option_verbose)
    {
	print "$0: leaving $directory\n";
    }

    chdir '..';
}


sub read_cmd_line
{
    my $option_help = 0;
    my $option_version;

    my $result
	= GetOptions(
		     "help!" => \$option_help,
		     "tags=s" => $option_tags,
		     "verbose+" => \$option_verbose,
		     "version" => \$option_version,
		    );

    if (!$result)
    {
	die "$0: *** Error: Error in option processing";
    }

    if ($option_version)
    {
    }

    # reporting options

    if ($option_help)
    {
	$0 =~ m(.*/(.*));

	my $program_name = $1;

	print
	    "

$program_name: build documentation and prepare them for web
publication.  Arguments on the command line are taken as documents
that need to be build.  If no arguments are given, all documents will
be build.

options:
    --help            print usage information.
    --tags            process the documents with these tags, multiple tags options may be given.
    --version         give version information.
    --v|verbose       tell what is being done, specify multiple times to get more feedback.

";

	exit 1;
    }

}


main();


