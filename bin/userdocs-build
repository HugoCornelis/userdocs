#!/usr/bin/perl -w
#!/usr/bin/perl -w -d:ptkdb 
#


use strict;


use Getopt::Long;

use YAML;


my $option_verbose;
my $option_tags = [];


sub build_document
{
    my $document = shift;

#     $document = m((.*)/(.*));

    my $directory = $document;

#     my $filename = $2;

    if ($option_verbose)
    {
	print "$0: entering $directory\n";
    }

    chdir $directory;

    # if we find a makefile

    if (-f 'Makefile')
    {
	# that is what we use

	system "make build_document";
    }
    else
    {
	# find relevant source files

	my $filenames
	    = [
	       map
	       {
		   chomp; $_
	       }
	       `ls *.tex`,
	      ];

	# loop over source files

	foreach my $filename (@$filenames)
	{
	    # for latex sources

	    if ($filename =~ /\.tex$/)
	    {
		chdir "output";

		# prepare output: general latex processing

		$filename =~ m((.*)\.tex$);

		my $filename_base = $1;

		system "latex '$filename'";

		system "makeindex -c '$filename_base'";

		system "bibtex '$filename_base'";

		system "latex '$filename'";
		system "latex '$filename'";

		# generate ps output

		{
		    mkdir "ps";

		    if ($option_verbose)
		    {
			print "$0: entering ps\n";
		    }

		    chdir "ps";

		    system "dvips '../$filename_base.dvi' -o '$filename_base.ps'";

		    if ($option_verbose)
		    {
			print "$0: leaving ps\n";
		    }

		    chdir "..";
		}

		# generate pdf output

		{
		    mkdir "pdf";

		    if ($option_verbose)
		    {
			print "$0: entering pdf\n";
		    }

		    chdir "pdf";

		    system "ps2pdf '../ps/$filename_base.ps' '$filename_base.pdf'";

		    if ($option_verbose)
		    {
			print "$0: leaving pdf\n";
		    }

		    chdir "..";
		}

		# generate html output

		{
		    mkdir 'html';
		    mkdir 'html/figures';

		    if ($option_verbose)
		    {
			print "$0: entering html\n";
		    }

		    chdir "html";

		    # read latex source

		    use IO::File;

		    my $source_file = IO::File->new("<../$filename");

		    my $source_text = join "", <$source_file>;

		    $source_file->close();

		    # convert pdf links to html links

		    $source_text =~ s(\\href\{\.\./([^}]*)\.pdf)(\\href\{../$1.html)g;

		    $source_text =~ s(\\href\{\.\./([^}]*)\.tex)(\\href\{../$1.html)g;



		    #remove any of the links to itself if it's a contents file.

		    if( $filename =~ m/contents-level[1234567]/)
		    {

		      my @name = split(/\./,$filename);

		      $source_text =~ s(\\item \\href\{\.\.\/\.\/$name[0]\/.*\.html\}\{\\bf \\underline\{.*\}\})( )g;

		    }

	

		    # If we have nothign but whitespace in between the itemize tags, remove
		    # the whole line. 
		    $source_text =~ s(\\begin\{itemize\}\s+\\end\{itemize\})( )g;

		    # convert eps links to png links

		    $source_text =~ s(\\includegraphics\{figures/([^}]*)\.eps)(\\href\{figures/$1.png)g;

		    # write converted source

		    $source_file = IO::File->new(">$filename");

		    print $source_file $source_text;

		    $source_file->close();

		    # copy figures

		    system "cp -rp ../figures/* figures/";

		    # generate html output

		    system "htlatex '$filename'";


		    if ($option_verbose)
		    {
			print "$0: leaving html\n";
		    }

		    chdir "..";
		}

		chdir "..";
	    }

	    # else unknown source file type

	    else
	    {
		print "$0: unknown file type for $filename";
	    }
	}
    }

    if ($option_verbose)
    {
	print "$0: leaving $directory\n";
    }

    chdir '..';
}


sub main
{
    read_cmd_line();

    # get all documents from the command line

    my $documents
	= {
	   map
	   {
	       $_ => 1,
	   }
	   @ARGV,
	  };

    # get all documents selected by tags

    foreach my $tag (@$option_tags)
    {
	local $/;

	my $documents_tag = Load(`userdocs-tag-filter 2>&1 "$tag" "published"`);

	if (!scalar @$documents_tag)
	{
	    next;
	}
	
	$documents
	    = {
	       %$documents,
	       map
	       {
		   $_ => 1,
	       }
	       @{ $documents_tag  },
	      };
    }

    # make sure document names are 'compliant'

    map
    {
	s(/$)();
    }
	keys %$documents;

    # prepare directory structure

    `mkdir -p html/htdocs/neurospaces_project/userdocs/`;

    if (!scalar keys %$documents)
    {
	print "$0: no documents to build\n";
    }

    foreach my $document (keys %$documents)
    {
	build_document($document);
    }

    foreach my $document (keys %$documents)
    {
	prepare_publish_document($document);
    }
}


sub prepare_publish_document
{
    my $document = shift;

#     $document = m((.*)/(.*));

    my $directory = $document;

#     my $filename = $2;

    if ($option_verbose)
    {
	print "$0: entering $directory\n";
    }

    chdir $directory;

    # if we find a makefile

    if (-f 'Makefile')
    {
	# that is what we use

	system "make prepare_publish_document";
    }

    # no makefile

    else
    {
	# find relevant output containing generated files

	my $outputs
	    = [
	       'output/html',
	      ];

	# loop over source files

	foreach my $output (@$outputs)
	{

	    my @tmp = split(/\//,$directory);

	    my $target_directory = $tmp[-1];

	    if ($option_verbose)
	    {
		print "$0: copying files for $directory to html/htdocs/neurospaces_project/userdocs/$target_directory\n";
	    }

	    # put it in the place for publication.

	    mkdir "../html/htdocs/neurospaces_project/userdocs/$target_directory";

	    #! note: -pr for BSD (MAC) compatibility.

	    system "cp -pr $output/* '../html/htdocs/neurospaces_project/userdocs/$target_directory'";

	    if ($?)
	    {
		print "$0: cp '$output' failed for $directory (error code $?)\n";
	    }
	}
    }

    if ($option_verbose)
    {
	print "$0: leaving $directory\n";
    }

    chdir '..';
}


sub read_cmd_line
{
    my $option_help = 0;
    my $option_version;

    my $result
	= GetOptions(
		     "help!" => \$option_help,
		     "tags=s" => $option_tags,
		     "verbose+" => \$option_verbose,
		     "version" => \$option_version,
		    );

    if (!$result)
    {
	die "$0: *** Error: Error in option processing";
    }

    if ($option_version)
    {
    }

    # reporting options

    if ($option_help)
    {
	$0 =~ m(.*/(.*));

	my $program_name = $1;

	print
	    "

$program_name: build documentation and prepare them for web
publication.  Arguments on the command line are taken as documents
that need to be build.  If no arguments are given, all documents will
be build.

options:
    --help            print usage information.
    --tags            process the documents with these tags, multiple tags options may be given.
    --version         give version information.
    --v|verbose       tell what is being done, specify multiple times to get more feedback.

";

	exit 1;
    }

}


main();


