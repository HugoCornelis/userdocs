#!/usr/bin/perl -w 
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


use Getopt::Long;

use YAML;


my $option_verbose;
my $option_tags = [];




sub build_document
{
    my $document = shift;

#     $document = m((.*)/(.*));

    my $directory = $document;

#     my $filename = $2;

    if ($option_verbose)
    {
	print "$0: entering $directory\n";
    }

    chdir $directory;

    # if we find a makefile

    if (-f 'Makefile')
    {
	# that is what we use

	system "make build_document";
    }
    else
    {
	# find relevant source files

	my $filenames
	    = [
	       map
	       {
		   chomp; $_
	       }
	       `ls *.tex`,
	      ];

	# loop over source files

	foreach my $filename (@$filenames)
	{
	    # for latex sources

	    if ($filename =~ /\.tex$/)
	    {
		chdir "output";

		# prepare output: general latex processing

		$filename =~ m((.*)\.tex$);


		#
		# Remove references to self, as well as any empty itemize blocks
		# since the itemize blocks kill the cron job. After we remove
		# the references we resave the file.
		#
		if( $filename =~ m/contents-level[1234567]/)
		{

		  # read latex source

		  use IO::File;

		  my $source_file = IO::File->new("<../$filename");

		  my $source_text = join "", <$source_file>;

		  $source_file->close();

		  my @name = split(/\./,$filename);

		  $source_text =~ s(\\item \\href\{\.\.\/$name[0]\/$name[0]\.\w+\}\{\\bf \\underline\{.*\}\})( )g;

		  # If we have nothing but whitespace in between the itemize tags, remove
		  # the whole line.
		  $source_text =~ s(\\begin\{itemize\}\s+\\end\{itemize\})( )g;


		  open(OUTPUT,">$filename");
		
		  print OUTPUT $source_text;
		  close(OUTPUT);

		}

		my $filename_base = $1;

		system "latex '$filename'";

		system "makeindex -c '$filename_base'";

		system "bibtex '$filename_base'";

		system "latex '$filename'";
		system "latex '$filename'";

		# generate ps output

		{
		    mkdir "ps";

		    if ($option_verbose)
		    {
			print "$0: entering ps\n";
		    }

		    chdir "ps";

		    system "dvips '../$filename_base.dvi' -o '$filename_base.ps'";

		    if ($option_verbose)
		    {
			print "$0: leaving ps\n";
		    }

		    chdir "..";
		}

		# generate pdf output

		{
		    mkdir "pdf";

		    if ($option_verbose)
		    {
			print "$0: entering pdf\n";
		    }

		    chdir "pdf";

		    system "ps2pdf '../ps/$filename_base.ps' '$filename_base.pdf'";

		    if ($option_verbose)
		    {
			print "$0: leaving pdf\n";
		    }

		    chdir "..";
		}

		# generate html output

		{
		    mkdir 'html';
		    mkdir 'html/figures';

		    if ($option_verbose)
		    {
			print "$0: entering html\n";
		    }

		    chdir "html";

		    # read latex source

		    use IO::File;

		    my $source_file = IO::File->new("<../$filename");

		    my $source_text = join "", <$source_file>;

		    $source_file->close();

		    # convert pdf links to html links


		    $source_text =~ s(\\href\{\.\./([^}]*)\.pdf)(\\href\{../$1.html)g;

		    $source_text =~ s(\\href\{\.\./([^}]*)\.tex)(\\href\{../$1.html)g;

		    #
		    # since the bog links are not html they need to stay as pdf.
		    # This just changes them back. 
		    $source_text =~ s(\\href\{\.\./bog-ch\d/(bog-ch\d)\.html)(\\href\{../$1/$1.pdf)g;

		    #remove any of the links to itself if it's a contents file.
		    #X this has been moved up earlier in the code
		    #XX readded this code because the previous code doesn't seem to be getting triggered.

#   		    if( $filename =~ m/contents-level1/)
#   		    {

#   		      my @name = split(/\./,$filename);

#   		      $source_text =~ s(\\item \\href\{\.\.\/\.\/$name[0]\/.*\.html\}\{\\bf \\underline\{.*\}\})( )g;

#   		    }

	

# 		    # If we have nothign but whitespace in between the itemize tags, remove
# 		    # the whole line.
 		    $source_text =~ s(\\begin\{itemize\}\s+\\end\{itemize\})( )g;

		    # convert eps links to png links

		    $source_text =~ s(\\includegraphics\{figures/([^}]*)\.eps)(\\href\{figures/$1.png)g;

		    # write converted source

		    $source_file = IO::File->new(">$filename");

		    print $source_file $source_text;

		    $source_file->close();

		    # copy figures

		    system "cp -rp ../figures/* figures/";

		    # generate html output

		    system "htlatex '$filename'";


		    if ($option_verbose)
		    {
			print "$0: leaving html\n";
		    }

		    chdir "..";
		}

		chdir "..";
	    }

	    # else unknown source file type

	    else
	    {
		print "$0: unknown file type for $filename";
	    }
	}
    }

    if ($option_verbose)
    {
	print "$0: leaving $directory\n";
    }

    chdir '..';
}


sub main
{
    read_cmd_line();

    # get all documents from the command line

    my $documents
	= {
	   map
	   {
	       $_ => 1,
	   }
	   @ARGV,
	  };

    # get all documents selected by tags

    foreach my $tag (@$option_tags)
    {
	local $/;

	my $documents_tag = Load(`userdocs-tag-filter 2>&1 "$tag" "published"`);

	if (!scalar @$documents_tag)
	{
	    next;
	}
	
	$documents
	    = {
	       %$documents,
	       map
	       {
		   $_ => 1,
	       }
	       @{ $documents_tag  },
	      };
    }

    # make sure document names are 'compliant'

    map
    {
	s(/$)();
    }
	keys %$documents;

    # prepare directory structure

    `mkdir -p html/htdocs/neurospaces_project/userdocs/`;

    # copy over the bog-ch files since they're PDFs and don't need any processing. 
    # Should make these directories respect the tag system.
    system "cp -pr bog-ch* 'html/htdocs/neurospaces_project/userdocs'";

    if (!scalar keys %$documents)
    {
	print "$0: no documents to build\n";
    }

    foreach my $document (keys %$documents)
    {
	build_document($document);
    }

    foreach my $document (keys %$documents)
    {
	prepare_publish_document($document);
    }
}



# 
# ($contents_page_text)
#
sub update_links
{
  my $tmp = shift;
  my @items = split(/\n/,$tmp);
  my $item;
  my $descriptorfile;

  my @updated_links;

  foreach $item (@items)
  {

    if($item =~ m/\\href\{\.\.\/(.*\/).*.pdf\}{/)
    {

      $descriptorfile = $1 . "descriptor.yml";
      
      if(-e $descriptorfile)
      {

	my $descriptor = YAML::LoadFile($descriptorfile);

	if(!defined $descriptor)
	{

	  print "Error: $descriptorfile contains invalid YAML\n";
	  next;

	}


	# NOTE: This line is used to change the filename to the human readable name
	# , the previous regex was underline{.*} which worked, then for some reason
	# it stopped working so I changed it to .+, now it works again. 
	my $document_name = $descriptor->{'document name'};

	$item =~ s({\\bf \\underline{.+}})({\\bf \\underline{$document_name}})g;

	push(@updated_links,$item);
	
      }
      else
      {

	print "Error: $descriptorfile doesn't exist\n";
	next;

      }

    }

  }

  return  join "", @updated_links;

}




sub prepare_publish_document
{
    my $document = shift;

#     $document = m((.*)/(.*));

    my $directory = $document;

#     my $filename = $2;

    if ($option_verbose)
    {
	print "$0: entering $directory\n";
    }

    chdir $directory;

    # if we find a makefile

    if (-f 'Makefile')
    {
	# that is what we use

	system "make prepare_publish_document";
    }

    # no makefile

    else
    {
	# find relevant output containing generated files

	my $outputs
	    = [
	       'output/html',
	      ];

	# loop over source files

	foreach my $output (@$outputs)
	{

	    my @tmp = split(/\//,$directory);

	    my $target_directory = $tmp[-1];

	    if ($option_verbose)
	    {
		print "$0: copying files for $directory to html/htdocs/neurospaces_project/userdocs/$target_directory\n";
	    }

	    # put it in the place for publication.

	    mkdir "../html/htdocs/neurospaces_project/userdocs/$target_directory";

	    #! note: -pr for BSD (MAC) compatibility.

	    system "cp -pr $output/* '../html/htdocs/neurospaces_project/userdocs/$target_directory'";


	    if ($?)
	    {
		print "$0: cp '$output' failed for $directory (error code $?)\n";
	    }
	}
    }

    if ($option_verbose)
    {
	print "$0: leaving $directory\n";
    }

    chdir '..';
}


sub read_cmd_line
{
    my $option_help = 0;
    my $option_version;

    my $result
	= GetOptions(
		     "help!" => \$option_help,
		     "tags=s" => $option_tags,
		     "verbose+" => \$option_verbose,
		     "version" => \$option_version,
		    );

    if (!$result)
    {
	die "$0: *** Error: Error in option processing";
    }

    if ($option_version)
    {
    }

    # reporting options

    if ($option_help)
    {
	$0 =~ m(.*/(.*));

	my $program_name = $1;

	print
	    "

$program_name: build documentation and prepare them for web
publication.  Arguments on the command line are taken as documents
that need to be build.  If no arguments are given, all documents will
be build.

options:
    --help            print usage information.
    --tags            process the documents with these tags, multiple tags options may be given.
    --version         give version information.
    --v|verbose       tell what is being done, specify multiple times to get more feedback.

";

	exit 1;
    }

}


main();


