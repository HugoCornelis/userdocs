#!/usr/bin/perl -w 
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


BEGIN
{
    #! make check

    push @INC, '../perl';
    #! make distcheck

    push @INC, '../../perl';

    #! normal run

    push @INC, './perl';

    #! after install

    push @INC, '/usr/local/glue/swig/perl';
}


use GENESIS3::Documentation;

use Getopt::Long;

use YAML;


my $option_parse_only = 0;
my $option_regex = ".*";
my $option_tags = [];
my $option_verbose;


sub main
{
    read_cmd_line();

    # switch to the build directory

    my $build_directory = "$ENV{HOME}/neurospaces_project/userdocs/source/snapshots/0/";

    if (!chdir $build_directory)
    {
	die "$0: cannot change to the build directory ($build_directory)";
    }

    # get all documents from the command line

    my $documents
	= {
	   map
	   {
	       $_ => 1,
	   }
	   (
	    @ARGV
	    ? @ARGV
	    : @{ local $/ ; Load(`userdocs-tag-filter 2>&1 "published"`) },
	   ),
	  };

    # get all documents selected by tags

    foreach my $tag (@$option_tags)
    {
	local $/;

	my $documents_tag = Load(`userdocs-tag-filter 2>&1 "published" "$tag"`);

	if (!scalar @$documents_tag)
	{
	    next;
	}
	
	$documents
	    = {
	       %$documents,
	       map
	       {
		   $_ => $tag,
	       }
	       @$documents_tag,
	      };
    }

    # start the publication process

    GENESIS3::Documentation::Publications::start_publication_production();

    # prepare directory structure

    `mkdir -p html/htdocs/neurospaces_project/userdocs/`;

    if (!scalar keys %$documents)
    {
	print "$0: no documents to build\n";
    }

    foreach my $document_name (sort keys %$documents)
    {
	$document_name =~ s(/$)();

	$document_name =~ s(.*/)();

	chomp $document_name;

	if ($document_name !~ m/$option_regex/)
	{
	    next;
	}

	my $document
	    = GENESIS3::Documentation::Document->new
		(
		 {
		  name => $document_name,
		 },
		);

	# copy the document sources to the build directory

	my $copy_error = $document->copy( { verbose => $option_verbose, }, );

	if ($copy_error)
	{
	    print "$0: *** Error: for document $document_name: failed to copy ($copy_error)\n";
	}

	# expand keywords and snippets inside the document source

	my $expansion_error = $document->expand( { verbose => $option_verbose, }, );

	if ($expansion_error)
	{
	    print "$0: *** Error: for document $document_name: failed to expand ($expansion_error)\n";
	}

	# build the document with the expansions

	my $build_error = $document->build( { verbose => $option_verbose, }, );

	if ($build_error)
	{
	    print "$0: *** Error: for document $document_name: failed to build ($build_error)\n";
	}

	# copy the result to the destination directory

	my $publish_error = $document->prepare_publish_document( { verbose => $option_verbose, }, );

	if ($publish_error)
	{
	    print "$0: *** Error: for document $document_name: failed to publish ($publish_error)\n";
	}

# 	if ($build_error
# 	    or $copy_error
# 	    or $publish_error)
	{
	    GENESIS3::Documentation::Publications::insert_publication_production_result
		    (
		     $document_name,
		     {
		      '1. copy_error' => $copy_error,
		      '2. expansion_error' => $expansion_error,
		      '3. build_error' => $build_error,
		      '4. publish_error' => $publish_error,
		     }
		    );
	}
    }

    # now also publish the publication production results

    GENESIS3::Documentation::Publications::publish_production_results();
}


sub read_cmd_line
{
    my $option_help = 0;
    my $option_version;

    my $result
	= GetOptions(
		     "help!" => \$option_help,
		     "parse-only!" => \$option_parse_only,
		     "regex=s" => \$option_regex,
		     "tags=s" => $option_tags,
		     "verbose+" => \$option_verbose,
		     "version" => \$option_version,
		    );

    if (!$result)
    {
	die "$0: *** Error: Error in option processing";
    }

    if ($option_version)
    {
    }

    # reporting options

    if ($option_help)
    {
	$0 =~ m(.*/(.*));

	my $program_name = $1;

	print
	    "

$program_name: build documentation and prepare them for web
publication.  Arguments on the command line are taken as documents
that need to be build.  If no arguments are given, all documents will
be build.

synopsis:
    $0 <document name1> <document name2> ...

options:
    --help            print usage information.
    --parse-only      only execute parse commands, without actually building documentation.
    --regex           selects documents by name (default is all).
    --tags            process the documents with these tags, multiple tags options may be given.
    --version         give version information.
    --v|verbose       tell what is being done, specify multiple times to get more feedback.

example usage:
    userdocs-build documentation-homepage
    firefox html/htdocs/neurospaces_project/userdocs/documentation-homepage/documentation-homepage.html

";

	exit 1;
    }

}


main();


