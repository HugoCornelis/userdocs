#!/usr/bin/perl -w 
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


use Getopt::Long;

use YAML;


my $program_name = $0;


$program_name =~ s/.*\///;


# parse options

my $option_help;
my $option_remove;
my $option_verbose;




#
# args ($path)
#
# shortens the full paths returned by the descriptor
# finds.
sub get_relative_path
{
  my $path = shift;

  my @tmp = split(/\//,$path);

  my $relative_path = $tmp[-1];

  return $relative_path;

}



#
# args (@paths)
#
# converts an array of absolute paths to relative ones.
#
sub get_relative_paths
{

  my $fullpaths = shift;
  my @relative_paths;

  my $path;
  foreach (@$fullpaths)
  {

    $path = get_relative_path($_);

    push(@relative_paths,$path)

  }

  return @relative_paths;

}



sub read_cmd_line
{
    my $result
	= GetOptions
	    (
	     "help!" => \$option_help,
	     "remove!" => \$option_remove,
	     "v|verbose+" => \$option_verbose,
	    );

    if ($option_help)
    {
	print
	    "
$0: replace tags with the itemized contents in a set of documents.

$0 <options> <tag> <document1> ...

options :
    help            print usage information.
    remove          remove content between delimiters.
    verbose         set verbosity level.
";

	exit 1;
    }

}


sub tag_expander
{
    my $tag = shift;

    # expand the tag to its contents

    undef $/;


    my $result = YAML::Load(`userdocs-tag-filter '$tag'`);

    # return result

    return $result;
}




# A tag to check for in the given descriptor.
#  arg1 descriptor containing tags
#  arg2 tag to search for. 
#
#  note: duplicated code
#
# ($descriptor,$tag)
#
sub tag_defined
{
  my $descriptor = shift;
  my $tag = shift;

  my $tags = $descriptor->{tags};

  foreach (@$tags)
  {

    if( $tag eq $_ )
    {
      return 1;
    }
  }

  return 0;

}



# 
# ($contents_page_text)
#
sub update_links
{
 
  # Commented this since the previous method worked
  # fine, this one caused only the first entry in the array
  # to be processed.
  #my $tmp = shift;
  #my @items = split(/\n/,$tmp);

  my @items = @_;
  my $item;
  my $descriptorfile;

  my @updated_links;

  foreach $item (@items)
  {

    if($item =~ m/\\href\{\.\.\/(.*\/).*.pdf\}{/)
    {

      # chop should be safe here since it cuts off the "/"
      my $item_name = $1;
      chop($item_name);

      $descriptorfile = $1 . "descriptor.yml";

      if(-e $descriptorfile)
      {

	my $descriptor = YAML::LoadFile($descriptorfile);

	if(!defined $descriptor)
	{

	  print "Error: $descriptorfile contains invalid YAML\n";
	  next;

	}

	#
	# If the doc is flagged as a draft we skip
	# to the next item so this doesn't get added to our
	# updated list.
	#
	if( tag_defined($descriptor,'draft') )
	{
	  next;
	}
	
	my $document_name = $descriptor->{'document name'};


	$item =~ s({\\bf \\underline{.+}})({\\bf \\underline{$document_name}})g;

	push(@updated_links,$item);


	
      }
      else
      {

	print "Error: $descriptorfile doesn't exist\n";
	next;

      }

    }

  }


  # Sort the links on the contents pages by the document name. 
   my @updated_links_sorted = sort{
     my $atmp = $a;
     $atmp =~ s(\\item \\href{../.*/.*}{\\bf \\underline{(.*)}}\n\n)($1)g;
     my $btmp = $b;
     $btmp =~ s(\\item \\href{../.*/.*}{\\bf \\underline{(.*)}}\n\n)($1)g;

     lc($atmp) cmp lc($btmp)

   }@updated_links;

   return join "",@updated_links_sorted;


}


sub compare
{

}



sub main
{
    read_cmd_line();

    my $tag = shift @ARGV;

    my $files = [ @ARGV, ];

    if (!defined $tag)
    {
	die "$0: please give a tag value on the command line";
    }

    if (!@$files)
    {
	die "$0: please give a couple of filenames on the command line";
    }

    my $replacement;

    # if have to remove

    if ($option_remove)
    {
	$replacement = '';
    }

    # else

    else
    {
	# expand the tag to its items

	my $items = tag_expander($tag);


	# This is to convert the full pathnames returned
	# in tag_expander to relative ones since it breaks
	# the links.
	my @items_relative = get_relative_paths($items);

	my $items_expanded
	    = [
	       #t grep only those that have a 'published' tag

	       map
	       {
		   "\\item \\href{../$_/$_.pdf}{\\bf \\underline{$_}}\n\n";
	       }
	       sort
	       @items_relative,
	      ];

	#my $items_expanded_text = join "", @$items_expanded
	my $items_expanded_text = update_links(@$items_expanded);

	$replacement = "\\begin{itemize}\n\n$items_expanded_text\n\\end{itemize}\n\n";
    }

    # loop over all files

    foreach my $file (@$files)
    {
	if ($option_verbose)
	{
	    print STDERR "---------------------------------------------------------------------\n";
	    print STDERR "Expanding in \"$file\"\n";
	}

	my $content;

	{
	    # slurp content

	    open my $descriptor, $file
		or die $!;
	    undef $/;
	    $content = <$descriptor>;
	    close $descriptor;
	}

	if ($content)
	{
	    my $old_content = $content;

	    # loop over source text

	    #! assertion allows '"' to be escaped with a backslash

	    if ($content =~ m/% start: $program_name $tag(.*\n)*% end: $program_name $tag\n/)
	    {
		my $position = pos($content);

		if ($option_verbose)
		{
		    print STDERR "For $file: found $program_name $tag, expanding ... \n";
		}

		# replace the next line with the new text
		#X removed a \s* at the end of $tag, removed a newline from the end of the wildcard .*
		#$content =~ s/% start: $program_name $tag\s*\n(.*\n)*% end: $program_name $tag[^\n]*\n/% start: $program_name $tag\n$replacement% end: $program_name $tag\n/g;

		$content =~ s(% start: $program_name $tag(.*\n)*% end: $program_name $tag\n)(% start: $program_name $tag\n$replacement% end: $program_name $tag\n)g;

		if ($option_verbose)
		{
		    print STDERR "For $file: new content at position $position is $replacement\n";
		}

		pos($content) = $position;
	    }

	    if ($option_verbose)
	    {
		print STDERR "Done for $file\n";
		print STDERR "---------------------------------------------------------------------\n\n";
	    }

	    # if something has changed

	    if ($old_content ne $content)
	    {
		# replace the file

		open my $descriptor, ">$file"
		    or die $!;
		print $descriptor $content;
		close $descriptor;


	    }

	}
    }
}


main();


