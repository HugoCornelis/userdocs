\documentclass[12pt]{article}
\usepackage{verbatim}
\usepackage[dvips]{epsfig}
\usepackage{color}
\usepackage{url}
\usepackage[colorlinks=true]{hyperref}

\begin{document}

\section*{GENESIS: Documentation}

{\bf Related Documentation:}
% start: userdocs-tag-replace-items related-add-functionality
% end: userdocs-tag-replace-items related-add-functionality

\section*{Create and Add Solver Object to GENESIS 3}

This developer guide gives an example of how to add a new simulation
object and integrate this new
\href{../reserved-words/reserved-words.tex}{\bf Component} with
GENESIS.  As an example we implement the pulsegen object of GENESIS 2
that, for simplicity, we will embed as a new component in the {\bf
  Experiment} package.

\section*{Creating Source Files}

First we create the following source files for the new object in the correct places in {\bf Experiment}:
\begin{verbatim}
   pulsegen.c
   experiment/pulsegen.h
\end{verbatim}

These source files will be filled in with the functionality of the
GENESIS~2 pulsegen object.

\section*{Implementation}

\subsection*{Declarations}

\subsubsection*{Data Structure}

To keep track of all the data for the new object we define a struct(ure) which contains all of our variables. This structure is set up in the header file {\it experiment/pulsegen.h}:
\begin{verbatim}
   struct simobj_PulseGen
   {
   
      char *pcName;

      double dLevel1;
      double dWidth1;
      double dDelay1;

      double dLevel2;
      double dWidth2;
      double dDelay2;

      double dBaseLevel;

      double dTriggerTime;
      int iTriggerMode;
  
      int iPreviousInput;

      /// An input value referenced via pointer. 
  
      double *pdPulseIn;

      /// solved variables

      double *pdPulseOut;
   };
\end{verbatim}

\subsubsection*{Functions}

Keeping in mind that the new object is going to be used by a
simulation, we need appropriate functions for interaction with the
scheduler.  The most important functions are: creation and set up of
the object's run-time instance, performing the actions during a single
simulation step, and freeing the memory allocated by the object during
its lifetime.

\begin{itemize}
\item {\bf Creation and Set up of a new Pulse Generator:}
\begin{verbatim}
   struct simobj_PulseGen * PulseGenNew(char *pcName);
\end{verbatim}

\item {\bf Add a solved variable to the Pulse Generator:}
\begin{verbatim}
   int PulseGenAddVariable(struct simobj_PulseGen *ppg, void *pvOutput);
\end{verbatim}

\item{\bf Set data fields for the Pulse Generator:}
\begin{verbatim}
   int PulseGenSetFields
   (
      struct simobj_PulseGen *ppg,
      double dLevel1,
      double dWidth1,
      double dDelay1,
      double dLevel2,
      double dWidth2,
      double dDelay2,
      double dBaseLevel,
      int iTriggerMode
   );
\end{verbatim}

\item {\bf Reset the Pulse Generator:}
\begin{verbatim}
   int PulseGenReset(struct simobj_PulseGen *ppg);
\end{verbatim}

\item {\bf Perform a Step of a Simulation:}
\begin{verbatim}
   int PulseGenSingleStep(struct simobj_PulseGen *ppg, double dTime);
\end{verbatim}

\item {\bf Freeing Memory after the Simulation has Finished:}
\begin{verbatim}
   int PulseGenFinish(struct simobj_PulseGen *ppg);
\end{verbatim}

\end{itemize}

\subsection*{Add New Object to Make Targets}

Before compiling the new simulation object you must add your source files to targets of the {\bf Experiment} package {\it Makefile.am}.

\begin{itemize}
   \item In {\it libexperiment\_a\_SOURCES} add:
\begin{verbatim}
   pulsegen.c
\end{verbatim}
   \item In {\it nobase\_include\_HEADERS} add:
\begin{verbatim}
   experiment/pulsegen.h 
\end{verbatim}
\end{itemize}
The new simulation object will be compiled into the {\bf Experiment} library when a {\it make} is performed.

\end{document}
